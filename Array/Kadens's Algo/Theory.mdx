---
title: "Kadane's Algorithm"
description: "Find the maximum sum of a contiguous subarray in O(n) time and O(1) space."
tags:
  - algorithm
  - kadane
  - dynamic-programming
  - array
---

## Kadane's Algorithm

Kadane's Algorithm is a dynamic programming technique to find the maximum sum of a contiguous subarray in an array of integers. It's optimal in time and space: O(n) time and O(1) extra space.

### Key idea

- Maintain two values while scanning the array left-to-right:
  - `current_sum`: maximum sum of a subarray that ends at the current index.
  - `max_sum`: maximum sum seen so far across all subarrays.
- At each element, decide whether to extend the previous subarray or start a new one at the current element.

### Algorithm (high level)

1. Initialize `current_sum` and `max_sum` to the first element.
2. For each subsequent element `x`:
   - `current_sum = max(x, current_sum + x)` — either start at `x` or extend.
   - `max_sum = max(max_sum, current_sum)` — update the global maximum.
3. Return `max_sum`.
### JavaScript implementation

Below is a Node-friendly JavaScript implementation of Kadane's algorithm, followed by an optional variant that returns the start and end indices.

```javascript
// Kadane's algorithm (JavaScript / Node.js)
function maxSubarraySum(nums) {
	if (!Array.isArray(nums) || nums.length === 0) return 0;

	let maxSum = nums[0];
	let currentSum = nums[0];

	for (let i = 1; i < nums.length; i++) {
		currentSum = Math.max(nums[i], currentSum + nums[i]);
		maxSum = Math.max(maxSum, currentSum);
	}

	return maxSum;
}

// Optional: return sum and start/end indices
function maxSubarrayWithIndices(nums) {
	if (!Array.isArray(nums) || nums.length === 0) return { sum: 0, start: -1, end: -1 };

	let maxSum = nums[0];
	let currentSum = nums[0];
	let start = 0, end = 0, s = 0;

	for (let i = 1; i < nums.length; i++) {
		if (nums[i] > currentSum + nums[i]) {
			currentSum = nums[i];
			s = i;
		} else {
			currentSum += nums[i];
		}

		if (currentSum > maxSum) {
			maxSum = currentSum;
			start = s;
			end = i;
		}
	}

	return { sum: maxSum, start, end };
}

// If run directly with Node, show example outputs
if (typeof require !== 'undefined' && require.main === module) {
	console.log(maxSubarraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4])); // 6
	console.log(maxSubarraySum([1, 2, 3, 4, 5])); // 15
	console.log(maxSubarraySum([-1, -2, -3])); // -1

	console.log(maxSubarrayWithIndices([ -2, 1, -3, 4, -1, 2, 1, -5, 4 ]));
	// { sum: 6, start: 3, end: 6 }
}
```

### Explanation of the example

For the array `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`:

- Start: `current_sum = max_sum = -2`.
- At `1`: `current_sum = max(1, -2 + 1) = 1`, `max_sum = 1`.
- Later at `4`: `current_sum = max(4, 1 + 4) = 5`, `max_sum = 5`.
- Continuing yields the subarray `[4, -1, 2, 1]` with sum `6`, which is the maximum.

### Applications

- Stock price analysis: find the most profitable contiguous period.
- Signal/image processing: detect regions with maximum cumulative intensity.
- Data analysis: identify periods of growth in time-series data.

### Limitations and notes

- If all elements are negative, the algorithm returns the largest (least negative) element. If you prefer returning `0` for an empty selection, handle that case explicitly.
- Kadane's algorithm finds the maximum-sum contiguous subarray. It does not give the indices by default, but you can track start/end indices with a small modification.

Kadane's Algorithm is simple, fast, and widely used in competitive programming and real-world analytics.
